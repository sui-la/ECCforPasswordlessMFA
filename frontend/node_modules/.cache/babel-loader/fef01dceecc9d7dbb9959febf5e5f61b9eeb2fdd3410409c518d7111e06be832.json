{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\PycharmProjects\\\\ECCforPasswordlessMFA\\\\frontend\\\\src\\\\contexts\\\\AuthContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { api } from '../services/api';\nimport { cryptoService } from '../services/crypto';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext(undefined);\nexport const useAuth = () => {\n  _s();\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n_s(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [sessionToken, setSessionToken] = useState(null);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  // Check for existing session on app load\n  useEffect(() => {\n    const token = localStorage.getItem('sessionToken');\n    if (token) {\n      validateSession(token);\n    }\n  }, []);\n  const validateSession = async token => {\n    try {\n      const response = await api.post('/auth/session/validate', {\n        session_token: token\n      });\n      if (response.data.success) {\n        setUser(response.data);\n        setSessionToken(token);\n        setIsAuthenticated(true);\n      } else {\n        // Invalid session, clear storage\n        localStorage.removeItem('sessionToken');\n        setUser(null);\n        setSessionToken(null);\n        setIsAuthenticated(false);\n      }\n    } catch (error) {\n      console.error('Session validation error:', error);\n      localStorage.removeItem('sessionToken');\n      setUser(null);\n      setSessionToken(null);\n      setIsAuthenticated(false);\n    }\n  };\n  const login = async email => {\n    try {\n      const response = await api.post('/auth/login/initiate', {\n        email\n      });\n      if (response.data.success) {\n        // Store challenge info for verification\n        localStorage.setItem('challengeId', response.data.challenge_id);\n        localStorage.setItem('challengeNonce', response.data.nonce);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Login initiation error:', error);\n      return false;\n    }\n  };\n  const verifyChallenge = async (challengeId, signature) => {\n    try {\n      const response = await api.post('/auth/login/verify', {\n        challenge_id: challengeId,\n        signature: signature\n      });\n      if (response.data.success) {\n        setUser(response.data);\n        setSessionToken(response.data.session_token);\n        setIsAuthenticated(true);\n        localStorage.setItem('sessionToken', response.data.session_token);\n\n        // Clear challenge data\n        localStorage.removeItem('challengeId');\n        localStorage.removeItem('challengeNonce');\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Challenge verification error:', error);\n      return false;\n    }\n  };\n  const register = async (email, name) => {\n    try {\n      // Generate ECC keypair\n      const keyPair = await cryptoService.generateKeyPair();\n      const response = await api.post('/auth/register', {\n        email,\n        name,\n        public_key: keyPair.publicKeyPem\n      });\n      if (response.data.success) {\n        // Store private key securely (in production, use secure storage)\n        localStorage.setItem('privateKey', keyPair.privateKeyPem);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Registration error:', error);\n      return false;\n    }\n  };\n  const logout = async () => {\n    try {\n      if (sessionToken) {\n        await api.post('/auth/logout', {\n          session_token: sessionToken\n        });\n      }\n    } catch (error) {\n      console.error('Logout error:', error);\n    } finally {\n      // Clear all auth data\n      localStorage.removeItem('sessionToken');\n      localStorage.removeItem('privateKey');\n      localStorage.removeItem('challengeId');\n      localStorage.removeItem('challengeNonce');\n      setUser(null);\n      setSessionToken(null);\n      setIsAuthenticated(false);\n    }\n  };\n  const checkEmailAvailability = async email => {\n    try {\n      const response = await api.post('/auth/register/check-email', {\n        email\n      });\n      return response.data.success && response.data.available;\n    } catch (error) {\n      console.error('Email availability check error:', error);\n      return false;\n    }\n  };\n  const value = {\n    user,\n    isAuthenticated,\n    sessionToken,\n    login,\n    logout,\n    register,\n    verifyChallenge,\n    checkEmailAvailability\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 187,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"BjpeNYkNBanlexBMoYMBxwZXWsw=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","api","cryptoService","jsxDEV","_jsxDEV","AuthContext","undefined","useAuth","_s","context","Error","AuthProvider","children","_s2","user","setUser","sessionToken","setSessionToken","isAuthenticated","setIsAuthenticated","token","localStorage","getItem","validateSession","response","post","session_token","data","success","removeItem","error","console","login","email","setItem","challenge_id","nonce","verifyChallenge","challengeId","signature","register","name","keyPair","generateKeyPair","public_key","publicKeyPem","privateKeyPem","logout","checkEmailAvailability","available","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/User/PycharmProjects/ECCforPasswordlessMFA/frontend/src/contexts/AuthContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { api } from '../services/api';\nimport { cryptoService } from '../services/crypto';\n\ninterface User {\n  user_id: string;\n  email: string;\n  name?: string;\n  created_at: string;\n  last_login?: string;\n}\n\ninterface AuthContextType {\n  user: User | null;\n  isAuthenticated: boolean;\n  sessionToken: string | null;\n  login: (email: string) => Promise<boolean>;\n  logout: () => void;\n  register: (email: string, name?: string) => Promise<boolean>;\n  verifyChallenge: (challengeId: string, signature: string) => Promise<boolean>;\n  checkEmailAvailability: (email: string) => Promise<boolean>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [sessionToken, setSessionToken] = useState<string | null>(null);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  // Check for existing session on app load\n  useEffect(() => {\n    const token = localStorage.getItem('sessionToken');\n    if (token) {\n      validateSession(token);\n    }\n  }, []);\n\n  const validateSession = async (token: string) => {\n    try {\n      const response = await api.post('/auth/session/validate', {\n        session_token: token\n      });\n\n      if (response.data.success) {\n        setUser(response.data);\n        setSessionToken(token);\n        setIsAuthenticated(true);\n      } else {\n        // Invalid session, clear storage\n        localStorage.removeItem('sessionToken');\n        setUser(null);\n        setSessionToken(null);\n        setIsAuthenticated(false);\n      }\n    } catch (error) {\n      console.error('Session validation error:', error);\n      localStorage.removeItem('sessionToken');\n      setUser(null);\n      setSessionToken(null);\n      setIsAuthenticated(false);\n    }\n  };\n\n  const login = async (email: string): Promise<boolean> => {\n    try {\n      const response = await api.post('/auth/login/initiate', { email });\n      \n      if (response.data.success) {\n        // Store challenge info for verification\n        localStorage.setItem('challengeId', response.data.challenge_id);\n        localStorage.setItem('challengeNonce', response.data.nonce);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Login initiation error:', error);\n      return false;\n    }\n  };\n\n  const verifyChallenge = async (challengeId: string, signature: string): Promise<boolean> => {\n    try {\n      const response = await api.post('/auth/login/verify', {\n        challenge_id: challengeId,\n        signature: signature\n      });\n\n      if (response.data.success) {\n        setUser(response.data);\n        setSessionToken(response.data.session_token);\n        setIsAuthenticated(true);\n        localStorage.setItem('sessionToken', response.data.session_token);\n        \n        // Clear challenge data\n        localStorage.removeItem('challengeId');\n        localStorage.removeItem('challengeNonce');\n        \n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Challenge verification error:', error);\n      return false;\n    }\n  };\n\n  const register = async (email: string, name?: string): Promise<boolean> => {\n    try {\n      // Generate ECC keypair\n      const keyPair = await cryptoService.generateKeyPair();\n      \n      const response = await api.post('/auth/register', {\n        email,\n        name,\n        public_key: keyPair.publicKeyPem\n      });\n\n      if (response.data.success) {\n        // Store private key securely (in production, use secure storage)\n        localStorage.setItem('privateKey', keyPair.privateKeyPem);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Registration error:', error);\n      return false;\n    }\n  };\n\n  const logout = async () => {\n    try {\n      if (sessionToken) {\n        await api.post('/auth/logout', {\n          session_token: sessionToken\n        });\n      }\n    } catch (error) {\n      console.error('Logout error:', error);\n    } finally {\n      // Clear all auth data\n      localStorage.removeItem('sessionToken');\n      localStorage.removeItem('privateKey');\n      localStorage.removeItem('challengeId');\n      localStorage.removeItem('challengeNonce');\n      \n      setUser(null);\n      setSessionToken(null);\n      setIsAuthenticated(false);\n    }\n  };\n\n  const checkEmailAvailability = async (email: string): Promise<boolean> => {\n    try {\n      const response = await api.post('/auth/register/check-email', { email });\n      return response.data.success && response.data.available;\n    } catch (error) {\n      console.error('Email availability check error:', error);\n      return false;\n    }\n  };\n\n  const value: AuthContextType = {\n    user,\n    isAuthenticated,\n    sessionToken,\n    login,\n    logout,\n    register,\n    verifyChallenge,\n    checkEmailAvailability\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}