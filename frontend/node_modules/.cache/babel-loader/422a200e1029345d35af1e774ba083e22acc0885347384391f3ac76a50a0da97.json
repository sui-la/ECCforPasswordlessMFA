{"ast":null,"code":"// Crypto service for ECC operations using Web Crypto API\n\nclass CryptoService {\n  constructor() {\n    this.algorithm = {\n      name: 'ECDSA',\n      namedCurve: 'P-256'\n    };\n    this.exportFormat = 'spki';\n    this.extractable = true;\n  }\n  /**\n   * Generate ECC key pair\n   */\n  async generateKeyPair() {\n    try {\n      // Generate key pair\n      const keyPair = await window.crypto.subtle.generateKey(this.algorithm, this.extractable, ['sign', 'verify']);\n\n      // Export keys to PEM format\n      const publicKeyPem = await this.exportPublicKey(keyPair.publicKey);\n      const privateKeyPem = await this.exportPrivateKey(keyPair.privateKey);\n      return {\n        privateKey: keyPair.privateKey,\n        publicKey: keyPair.publicKey,\n        privateKeyPem,\n        publicKeyPem\n      };\n    } catch (error) {\n      console.error('Error generating key pair:', error);\n      throw new Error('Failed to generate key pair');\n    }\n  }\n\n  /**\n   * Import private key from PEM format\n   */\n  async importPrivateKey(privateKeyPem) {\n    try {\n      const privateKeyData = this.pemToArrayBuffer(privateKeyPem, 'PRIVATE KEY');\n      return await window.crypto.subtle.importKey('pkcs8', privateKeyData, this.algorithm, this.extractable, ['sign']);\n    } catch (error) {\n      console.error('Error importing private key:', error);\n      throw new Error('Failed to import private key');\n    }\n  }\n\n  /**\n   * Import public key from PEM format\n   */\n  async importPublicKey(publicKeyPem) {\n    try {\n      const publicKeyData = this.pemToArrayBuffer(publicKeyPem, 'PUBLIC KEY');\n      return await window.crypto.subtle.importKey('spki', publicKeyData, this.algorithm, this.extractable, ['verify']);\n    } catch (error) {\n      console.error('Error importing public key:', error);\n      throw new Error('Failed to import public key');\n    }\n  }\n\n  /**\n   * Sign data with private key\n   */\n  async sign(privateKey, data) {\n    try {\n      const dataBuffer = typeof data === 'string' ? this.stringToArrayBuffer(data) : data;\n      const signature = await window.crypto.subtle.sign(this.algorithm, privateKey, dataBuffer);\n      return this.arrayBufferToBase64(signature);\n    } catch (error) {\n      console.error('Error signing data:', error);\n      throw new Error('Failed to sign data');\n    }\n  }\n\n  /**\n   * Verify signature with public key\n   */\n  async verify(publicKey, signature, data) {\n    try {\n      const dataBuffer = typeof data === 'string' ? this.stringToArrayBuffer(data) : data;\n      const signatureBuffer = this.base64ToArrayBuffer(signature);\n      return await window.crypto.subtle.verify(this.algorithm, publicKey, signatureBuffer, dataBuffer);\n    } catch (error) {\n      console.error('Error verifying signature:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Generate cryptographically secure random bytes\n   */\n  generateRandomBytes(length) {\n    const array = new Uint8Array(length);\n    window.crypto.getRandomValues(array);\n    return this.arrayBufferToBase64(array);\n  }\n\n  /**\n   * Export public key to PEM format\n   */\n  async exportPublicKey(publicKey) {\n    const exported = await window.crypto.subtle.exportKey('spki', publicKey);\n    const base64 = this.arrayBufferToBase64(exported);\n    return `-----BEGIN PUBLIC KEY-----\\n${base64}\\n-----END PUBLIC KEY-----`;\n  }\n\n  /**\n   * Export private key to PEM format\n   */\n  async exportPrivateKey(privateKey) {\n    const exported = await window.crypto.subtle.exportKey('pkcs8', privateKey);\n    const base64 = this.arrayBufferToBase64(exported);\n    return `-----BEGIN PRIVATE KEY-----\\n${base64}\\n-----END PRIVATE KEY-----`;\n  }\n\n  /**\n   * Convert PEM to ArrayBuffer\n   */\n  pemToArrayBuffer(pem, keyType) {\n    const base64 = pem.replace(`-----BEGIN ${keyType}-----`, '').replace(`-----END ${keyType}-----`, '').replace(/\\s/g, '');\n    return this.base64ToArrayBuffer(base64);\n  }\n\n  /**\n   * Convert string to ArrayBuffer\n   */\n  stringToArrayBuffer(str) {\n    const encoder = new TextEncoder();\n    return encoder.encode(str);\n  }\n\n  /**\n   * Convert ArrayBuffer to base64 string\n   */\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Convert base64 string to ArrayBuffer\n   */\n  base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  /**\n   * Hash data using SHA-256\n   */\n  async hash(data) {\n    const encoder = new TextEncoder();\n    const dataBuffer = encoder.encode(data);\n    const hashBuffer = await window.crypto.subtle.digest('SHA-256', dataBuffer);\n    return this.arrayBufferToBase64(hashBuffer);\n  }\n\n  /**\n   * Generate challenge nonce\n   */\n  generateNonce() {\n    return this.generateRandomBytes(32);\n  }\n\n  /**\n   * Sign challenge for authentication\n   */\n  async signChallenge(privateKeyPem, nonce) {\n    try {\n      const privateKey = await this.importPrivateKey(privateKeyPem);\n      return await this.sign(privateKey, nonce);\n    } catch (error) {\n      console.error('Error signing challenge:', error);\n      throw new Error('Failed to sign challenge');\n    }\n  }\n\n  /**\n   * Verify challenge signature\n   */\n  async verifyChallenge(publicKeyPem, signature, nonce) {\n    try {\n      const publicKey = await this.importPublicKey(publicKeyPem);\n      return await this.verify(publicKey, signature, nonce);\n    } catch (error) {\n      console.error('Error verifying challenge:', error);\n      return false;\n    }\n  }\n}\nexport const cryptoService = new CryptoService();","map":{"version":3,"names":["CryptoService","constructor","algorithm","name","namedCurve","exportFormat","extractable","generateKeyPair","keyPair","window","crypto","subtle","generateKey","publicKeyPem","exportPublicKey","publicKey","privateKeyPem","exportPrivateKey","privateKey","error","console","Error","importPrivateKey","privateKeyData","pemToArrayBuffer","importKey","importPublicKey","publicKeyData","sign","data","dataBuffer","stringToArrayBuffer","signature","arrayBufferToBase64","verify","signatureBuffer","base64ToArrayBuffer","generateRandomBytes","length","array","Uint8Array","getRandomValues","exported","exportKey","base64","pem","keyType","replace","str","encoder","TextEncoder","encode","buffer","bytes","binary","i","byteLength","String","fromCharCode","btoa","atob","charCodeAt","hash","hashBuffer","digest","generateNonce","signChallenge","nonce","verifyChallenge","cryptoService"],"sources":["C:/Users/User/PycharmProjects/ECCforPasswordlessMFA/frontend/src/services/crypto.ts"],"sourcesContent":["// Crypto service for ECC operations using Web Crypto API\nexport interface KeyPair {\n  privateKey: CryptoKey;\n  publicKey: CryptoKey;\n  privateKeyPem: string;\n  publicKeyPem: string;\n}\n\nexport interface SignatureResult {\n  signature: string;\n  publicKey: string;\n}\n\nclass CryptoService {\n  private algorithm = {\n    name: 'ECDSA',\n    namedCurve: 'P-256',\n  };\n\n  private exportFormat = 'spki';\n  private extractable = true;\n\n  /**\n   * Generate ECC key pair\n   */\n  async generateKeyPair(): Promise<KeyPair> {\n    try {\n      // Generate key pair\n      const keyPair = await window.crypto.subtle.generateKey(\n        this.algorithm,\n        this.extractable,\n        ['sign', 'verify']\n      );\n\n      // Export keys to PEM format\n      const publicKeyPem = await this.exportPublicKey(keyPair.publicKey);\n      const privateKeyPem = await this.exportPrivateKey(keyPair.privateKey);\n\n      return {\n        privateKey: keyPair.privateKey,\n        publicKey: keyPair.publicKey,\n        privateKeyPem,\n        publicKeyPem,\n      };\n    } catch (error) {\n      console.error('Error generating key pair:', error);\n      throw new Error('Failed to generate key pair');\n    }\n  }\n\n  /**\n   * Import private key from PEM format\n   */\n  async importPrivateKey(privateKeyPem: string): Promise<CryptoKey> {\n    try {\n      const privateKeyData = this.pemToArrayBuffer(privateKeyPem, 'PRIVATE KEY');\n      return await window.crypto.subtle.importKey(\n        'pkcs8',\n        privateKeyData,\n        this.algorithm,\n        this.extractable,\n        ['sign']\n      );\n    } catch (error) {\n      console.error('Error importing private key:', error);\n      throw new Error('Failed to import private key');\n    }\n  }\n\n  /**\n   * Import public key from PEM format\n   */\n  async importPublicKey(publicKeyPem: string): Promise<CryptoKey> {\n    try {\n      const publicKeyData = this.pemToArrayBuffer(publicKeyPem, 'PUBLIC KEY');\n      return await window.crypto.subtle.importKey(\n        'spki',\n        publicKeyData,\n        this.algorithm,\n        this.extractable,\n        ['verify']\n      );\n    } catch (error) {\n      console.error('Error importing public key:', error);\n      throw new Error('Failed to import public key');\n    }\n  }\n\n  /**\n   * Sign data with private key\n   */\n  async sign(privateKey: CryptoKey, data: string | ArrayBuffer): Promise<string> {\n    try {\n      const dataBuffer = typeof data === 'string' ? this.stringToArrayBuffer(data) : data;\n      const signature = await window.crypto.subtle.sign(\n        this.algorithm,\n        privateKey,\n        dataBuffer\n      );\n      return this.arrayBufferToBase64(signature);\n    } catch (error) {\n      console.error('Error signing data:', error);\n      throw new Error('Failed to sign data');\n    }\n  }\n\n  /**\n   * Verify signature with public key\n   */\n  async verify(\n    publicKey: CryptoKey,\n    signature: string,\n    data: string | ArrayBuffer\n  ): Promise<boolean> {\n    try {\n      const dataBuffer = typeof data === 'string' ? this.stringToArrayBuffer(data) : data;\n      const signatureBuffer = this.base64ToArrayBuffer(signature);\n      return await window.crypto.subtle.verify(\n        this.algorithm,\n        publicKey,\n        signatureBuffer,\n        dataBuffer\n      );\n    } catch (error) {\n      console.error('Error verifying signature:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Generate cryptographically secure random bytes\n   */\n  generateRandomBytes(length: number): string {\n    const array = new Uint8Array(length);\n    window.crypto.getRandomValues(array);\n    return this.arrayBufferToBase64(array);\n  }\n\n  /**\n   * Export public key to PEM format\n   */\n  private async exportPublicKey(publicKey: CryptoKey): Promise<string> {\n    const exported = await window.crypto.subtle.exportKey('spki', publicKey);\n    const base64 = this.arrayBufferToBase64(exported);\n    return `-----BEGIN PUBLIC KEY-----\\n${base64}\\n-----END PUBLIC KEY-----`;\n  }\n\n  /**\n   * Export private key to PEM format\n   */\n  private async exportPrivateKey(privateKey: CryptoKey): Promise<string> {\n    const exported = await window.crypto.subtle.exportKey('pkcs8', privateKey);\n    const base64 = this.arrayBufferToBase64(exported);\n    return `-----BEGIN PRIVATE KEY-----\\n${base64}\\n-----END PRIVATE KEY-----`;\n  }\n\n  /**\n   * Convert PEM to ArrayBuffer\n   */\n  private pemToArrayBuffer(pem: string, keyType: string): ArrayBuffer {\n    const base64 = pem\n      .replace(`-----BEGIN ${keyType}-----`, '')\n      .replace(`-----END ${keyType}-----`, '')\n      .replace(/\\s/g, '');\n    return this.base64ToArrayBuffer(base64);\n  }\n\n  /**\n   * Convert string to ArrayBuffer\n   */\n  private stringToArrayBuffer(str: string): ArrayBuffer {\n    const encoder = new TextEncoder();\n    return encoder.encode(str);\n  }\n\n  /**\n   * Convert ArrayBuffer to base64 string\n   */\n  private arrayBufferToBase64(buffer: ArrayBuffer | Uint8Array): string {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Convert base64 string to ArrayBuffer\n   */\n  private base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  /**\n   * Hash data using SHA-256\n   */\n  async hash(data: string): Promise<string> {\n    const encoder = new TextEncoder();\n    const dataBuffer = encoder.encode(data);\n    const hashBuffer = await window.crypto.subtle.digest('SHA-256', dataBuffer);\n    return this.arrayBufferToBase64(hashBuffer);\n  }\n\n  /**\n   * Generate challenge nonce\n   */\n  generateNonce(): string {\n    return this.generateRandomBytes(32);\n  }\n\n  /**\n   * Sign challenge for authentication\n   */\n  async signChallenge(privateKeyPem: string, nonce: string): Promise<string> {\n    try {\n      const privateKey = await this.importPrivateKey(privateKeyPem);\n      return await this.sign(privateKey, nonce);\n    } catch (error) {\n      console.error('Error signing challenge:', error);\n      throw new Error('Failed to sign challenge');\n    }\n  }\n\n  /**\n   * Verify challenge signature\n   */\n  async verifyChallenge(\n    publicKeyPem: string,\n    signature: string,\n    nonce: string\n  ): Promise<boolean> {\n    try {\n      const publicKey = await this.importPublicKey(publicKeyPem);\n      return await this.verify(publicKey, signature, nonce);\n    } catch (error) {\n      console.error('Error verifying challenge:', error);\n      return false;\n    }\n  }\n}\n\nexport const cryptoService = new CryptoService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}